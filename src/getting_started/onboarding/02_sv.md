# Week 2: System Verilog

---

## Purpose

This is a crash course in basic System Verilog constructs. As some level of
exposure to Verilog is a requirement for access to the team, this lab consists
of a series of exercises that will ensure you've got the basics on lock.

If you find there is a construct or challenge you're unsure how to approach,
seek guidance from the team. Asking questions is encouraged.

## Exercise 1: Warm Up

Implement the following opcode table with a single combinational `assign`
statement.

|    op    |      out
-----------|---------------
|     0    |     a + b
|     1    |     a - b
|     2    |     a & b
|     3    |     a \| b

## Exercise 2: Sequential Logic

Implement a xor-based Fibonacci Linear Feedback Register with taps at bits 15,
13, 12, and 10. If the reset is low, the LFSR should be initialized with the
value present on the init input bus.

Step the output on positive clock edge.

## Exercise 3: Module Composition

There are two Mystery modules under the Mysteries directory. Compose them
according to the following schematic:

<img src="/images/mystery_diag.png" width="70%" style="margin-left: auto; margin-right: auto; display: block;" />

**Make Note:** In the next lab you'll learn more about verification testing, but
for now take a quick glance at `dv/exercise1.cpp`, `dv/exercise2.cpp`, and
`dv/exercise3.cpp`. Exercise1 _exhaustively_ tests all possible inputs,
Exercise2 tests _samples_ some possible initial values for some cycles, and
Exercise3 _randomly_ tests inputs.

Why do you think the reason for these different testing approaches are? What
are their advantages and disadvantages?

## Exercise 4: Combinational Logic



## Exercise 5: Altogether Now
